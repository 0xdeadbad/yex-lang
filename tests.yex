def assert(condition, message) do
	if !condition then
		raise(@AssertionError, message)
		exit(1)
	end
end

let opsTests = [
	1 + 2 == 3,
	1 - 2 == -1,
	1 * 2 == 2,
	1 / 2 == 0.5,
	3 mod 2 == 1,
	1 <<< 2 == 4,
	1 >>> 2 == 0,
	1 &&& 2 == 0,
	1 ||| 2 == 3,
	1 ^^^ 2 == 3,
	1 == 1,
	1 != 2,
	1 < 2,
	1 <= 1,
	3 > 2,
	3 >= 3,
	1 && 2,
	1 || 0,
]

List#map(fn(test) do
	assert(test, "Operator test failed")
end, opsTests)

module Person
	def new(name, age) do
		assert(name is Str, "Name must be a string")
		assert(age is Num, "Age must be a number")
		%Person{name: name, age: age}
	end

	def adult?(this): this.age >= 18
end

let p = Person#new("John", 18)
assert(Person#adult?(p), "Person is not adult")
assert(p is Person, "p is not a Person")

try
	raise(@AssertionError, "should be rescued")
rescue e
	assert(e == @AssertionError, "Should be an assertion error")
end

assert(
	[1, 2, 3]
	|> List#map(fn(i): i * 2)
	|> List#map(fn(i): i + 1)
	|> List#filter(fn(i): i != 3)
	|> List#fold(0, fn(acc, i): acc + i)
	|> (fn(x): x == 12),
	"List tests failed",
)

def tailcall(counter, _) do
	when counter do
		else _ if counter > 0 =>
			->tailcall(counter - 1, _)
		0 => "Done"
	end
end

assert(tailcall(10, nil) == "Done", "Tailcall test failed")

def partial(a, b, c, d): a * b - c * d

let partialTest = [
	partial(1, 2, 3, 4) == -10,
	partial(1)(2, 3, 4) == -10,
	partial(1)(2, 3)(4) == -10,
	partial(1, 2)(3, 4) == -10,
	partial(1, 2, 3)(4) == -10,
]

List#map(fn(test) do
	assert(test, "Partial function test failed")
end, partialTest)

println("All tests passed")
